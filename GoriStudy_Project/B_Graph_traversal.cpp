//[2] 그래프 순회


//1. DFS (깊이 우선 탐색)

//무조건 보이는 쪽으로 탐색
//Stack을 이용해 구현한다만은 보통 실제 구현에서는 재귀 함수를 보통 쓴다.

/*
스택 구현

a. 시작 노드를 스택에 쌓는다(=방문한다).
b. 인접 노드를 스택에 쌓는다.
c. 해당(top) 노드에 아직 방문하지 않은 인접한 노드가 있으면 스택에 쌓고, 없으면 pop 한다.
d. 스택이 빌 때까지 반복
*/


//재귀 구현
void dfs(int x) { // 정점 x에서 dfs를 수행하는 함수 
	visited[x] = true; // 방문했으니 x를 방문처리한다 
	cout << x << ' ';

	// adj[x]는 x와 인접한 (x에서 갈 수 있는) 정점들의 목록
	for (int nx : adj[x]) {  // 여기서 nx로 다음 정점들을 하나씩 뽑아오자 
		if (!visited[nx]) { // 아직 nx가 미방문 정점이라면 
			dfs(nx); // nx에서 시작하는 dfs를 또 돌린다 
		} 
	}
}




//2. BFS (너비 우선 탐색)

// 현재 정점에서 갈 수 있는 곳을 다 돌고, 다음 정점으로 이동.
// Queue를 이용해 구현.
/*
a. 시작 노드를 큐에 넣는다(=방문한다)
b. 시작 노드의 모든 인접 노드를 큐에 넣는다.
c. front 노드에서 더 이상 방문할 인접노드가 없으면 큐에서 pop한다.
d. 큐가 텅 빌때까지 반복
*/


//BFS 구현

queue<int> q; 
// 처음에 시작 정점은 큐에 먼저 넣고, 방문처리하고 시작한다 
q.push(1); visited[1] = true; 

while (!q.empty()) { // 큐가 빌 때까지 (bfs가 끝날 때까지) 반복 
	nt x = q.front(); q.pop(); // 큐의 front가 현재 봐야 할 정점 
	cout << x << '\n';

	// dfs와 마찬가지로 adj[x]에서 하나씩 뽑아온다 
	for (int nx : adj[x]) { 
		if (!visited[nx]) { // 아직 미방문 정점이라면
			q.push(nx); 
			visited[nx] = true; // 큐에 넣고, 방문처리까지 
		} 
	}
}
