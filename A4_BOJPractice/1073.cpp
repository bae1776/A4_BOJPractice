//https://www.acmicpc.net/problem/1073

/* 도미노 (Platinum 3)

0 ~ 9 정점으로 이루어진 그래프에 대해
무방향 간선 리스트가 주어진다. (최대 45개)

그렇게 생성된 그래프에 대해 '사이클 콜렉션'의 갯수를 구하시오.
'사이클 콜렉션'은 모든 간선을 포함하면서 만들 수 있는 사이클 집합의 개수이다.
이때, 사이클의 시작이 다르더라도 같은 경로를 만들면 1개로 간주한다. (1-2-3-1 == 2-3-1-2)

Solution : 오일러 회로에 대한 이해가 필요하다.
오일러 회로란, 그래프의 모든 간선을 한번씩만 지나 다시 출발지로 돌아오는 사이클이다. (=한붓 그리기 + 시작점 복귀)
오일러 회로와 그래프 사이에는 중요한 동치 관계가 있다.
오일러 회로가 존재한다 <=> 그래프의 각 정점의 차수는 모두 짝수이다.  (2개가 홀수인 경우, 오일러 경로만 존재한다.)

사이클 콜렉션은 하나의 고유한 오일러 회로이다. (원순열처럼 출발 지점이 따로 없고, 역방향은 같은 것으로 간주됨)
사이클 콜렉션의 개수를 세기 위해서는, 정점 하나와 그 정점의 차수를 기준으로 볼 필요가 있다.

어떤 정점 A의 차수가 2라고 하자, 오일러 회로들(사이클 콜렉션)을 생성했을 때, 그 정점을 들어가고 나오는 방법은 단 1개이다. (B->A->C와 C->A->B는 동치이다.)
어떤 정점 A의 차수가 4라고 하면, 그 정점을 들어가고 나오는 방법은 3개이다. (4C2 / 2!)
                  6이면, 15이다. (6C2 * 4C2 / 3!)
                  8이면, 105이다. (8C2 * 6C2 * 4C2 / 4!)
여기서 A의 차수를 t, A를 들어가고 나가는 방법을 f(t) 라하면 f(t) = (t - 1) * f(t - 2) 이다. (t는 짝수)
그러면 이제 DP로 풀 수 있다!
그리고 총 사이클 콜렉션의 개수는, 각 정점마다의 출입 방법의 수의 곱이다.
*/

#include <iostream>
using namespace std;

int degree[10], DP[10];

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

    int edge;
    cin >> edge;

    while (edge--)
    {
        int input;
        cin >> input;

        degree[input / 10]++;
        degree[input % 10]++;
    }

    //차수에 대한 출입 경로 수 생성
    DP[2] = 1;
    DP[4] = 3 * DP[2];
    DP[6] = 5 * DP[4];
    DP[8] = 7 * DP[6];

    long long result = 1;
    for (int idx = 0; idx < 10; idx++)
    {
        if (degree[idx] == 0)
            continue;
        else if (degree[idx] % 2)
        {
            result = 0;  //홀수 차수의 정점이 있는 경우 모든 간선들을 커버하는 오일러 회로 집합은 절대로 존재할 수 없다.
            break;
        } else {
            result *= DP[degree[idx]];
        }
    }

    cout << result;
	
	return 0;
}